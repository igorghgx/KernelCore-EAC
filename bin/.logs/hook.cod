; Listing generated by Microsoft (R) Optimizing Compiler Version 19.36.32532.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	ExPoolZeroingNativelySupported
;	COMDAT ExPoolZeroingNativelySupported
_BSS	SEGMENT
ExPoolZeroingNativelySupported DB 01H DUP (?)
_BSS	ENDS
PUBLIC	?hooked_fptr@core_hook@@YA_JPEAX@Z		; core_hook::hooked_fptr
PUBLIC	?swap_process@@YA_K_K@Z				; swap_process
PUBLIC	?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z		; GetModuleBaseAddress
PUBLIC	?o_function_qword_1@core_hook@@3P6A_JPEAX@ZEA	; core_hook::o_function_qword_1
EXTRN	__imp_RtlInitAnsiString:PROC
EXTRN	__imp_RtlAnsiStringToUnicodeString:PROC
EXTRN	__imp_RtlCompareUnicodeString:PROC
EXTRN	__imp_RtlFreeUnicodeString:PROC
EXTRN	__imp_ExGetPreviousMode:PROC
EXTRN	__imp_ObfDereferenceObject:PROC
EXTRN	__imp_PsLookupProcessByProcessId:PROC
EXTRN	PsGetProcessPeb:PROC
EXTRN	PsGetProcessSectionBaseAddress:PROC
EXTRN	?write_process_memory@memory@@YAJII_K00PEA_K@Z:PROC ; memory::write_process_memory
EXTRN	?read_process_memory@memory@@YAJII_K00PEA_K@Z:PROC ; memory::read_process_memory
EXTRN	?get_by_id@process@@YAPEAU_KPROCESS@@IPEAJ@Z:PROC ; process::get_by_id
EXTRN	__guard_dispatch_icall_fptr:QWORD
;	COMDAT ?o_function_qword_1@core_hook@@3P6A_JPEAX@ZEA
_BSS	SEGMENT
?o_function_qword_1@core_hook@@3P6A_JPEAX@ZEA DQ 01H DUP (?) ; core_hook::o_function_qword_1
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68
	DD	imagerel $LN68+35
	DD	imagerel $unwind$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+35
	DD	imagerel $LN68+111
	DD	imagerel $chain$1$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+111
	DD	imagerel $LN68+200
	DD	imagerel $chain$3$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+200
	DD	imagerel $LN68+238
	DD	imagerel $chain$5$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+238
	DD	imagerel $LN68+250
	DD	imagerel $chain$7$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+250
	DD	imagerel $LN68+349
	DD	imagerel $chain$9$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+349
	DD	imagerel $LN68+415
	DD	imagerel $chain$10$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+415
	DD	imagerel $LN68+495
	DD	imagerel $chain$11$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+495
	DD	imagerel $LN68+551
	DD	imagerel $chain$12$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+551
	DD	imagerel $LN68+565
	DD	imagerel $chain$13$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+565
	DD	imagerel $LN68+586
	DD	imagerel $chain$14$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+586
	DD	imagerel $LN68+691
	DD	imagerel $chain$16$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$?hooked_fptr@core_hook@@YA_JPEAX@Z DD imagerel $LN68+691
	DD	imagerel $LN68+713
	DD	imagerel $chain$17$?hooked_fptr@core_hook@@YA_JPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z DD imagerel $LN35
	DD	imagerel $LN35+97
	DD	imagerel $unwind$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z DD imagerel $LN35+97
	DD	imagerel $LN35+154
	DD	imagerel $chain$0$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z DD imagerel $LN35+154
	DD	imagerel $LN35+238
	DD	imagerel $chain$1$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z DD imagerel $LN35+238
	DD	imagerel $LN35+286
	DD	imagerel $chain$2$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z DD imagerel $LN35+286
	DD	imagerel $LN35+297
	DD	imagerel $chain$3$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z DD 020022H
	DD	06001605H
	DD	imagerel $LN35
	DD	imagerel $LN35+97
	DD	imagerel $unwind$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z DD 022H
	DD	imagerel $LN35+97
	DD	imagerel $LN35+154
	DD	imagerel $chain$0$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z DD 020522H
	DD	0d7405H
	DD	imagerel $LN35+97
	DD	imagerel $LN35+154
	DD	imagerel $chain$0$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z DD 020522H
	DD	0c5405H
	DD	imagerel $LN35
	DD	imagerel $LN35+97
	DD	imagerel $unwind$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z DD 040902H
	DD	0e0057209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 020022H
	DD	06001608H
	DD	imagerel $LN68
	DD	imagerel $LN68+35
	DD	imagerel $unwind$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 040022H
	DD	0cc400H
	DD	0d7400H
	DD	imagerel $LN68
	DD	imagerel $LN68+35
	DD	imagerel $unwind$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 020022H
	DD	06001602H
	DD	imagerel $LN68+238
	DD	imagerel $LN68+250
	DD	imagerel $chain$7$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 022H
	DD	imagerel $LN68+250
	DD	imagerel $LN68+349
	DD	imagerel $chain$9$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 022H
	DD	imagerel $LN68+349
	DD	imagerel $LN68+415
	DD	imagerel $chain$10$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 020822H
	DD	0126408H
	DD	imagerel $LN68+349
	DD	imagerel $LN68+415
	DD	imagerel $chain$10$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 020822H
	DD	0115408H
	DD	imagerel $LN68+250
	DD	imagerel $LN68+349
	DD	imagerel $chain$9$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 041122H
	DD	0af411H
	DD	0be405H
	DD	imagerel $LN68+238
	DD	imagerel $LN68+250
	DD	imagerel $chain$7$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 040022H
	DD	0cc400H
	DD	0d7400H
	DD	imagerel $LN68
	DD	imagerel $LN68+35
	DD	imagerel $unwind$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 060022H
	DD	06001602H
	DD	0cc400H
	DD	0d7400H
	DD	imagerel $LN68
	DD	imagerel $LN68+35
	DD	imagerel $unwind$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 060022H
	DD	06001602H
	DD	0cc400H
	DD	0d7400H
	DD	imagerel $LN68
	DD	imagerel $LN68+35
	DD	imagerel $unwind$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 060d22H
	DD	06001602H
	DD	0d740dH
	DD	0cc405H
	DD	imagerel $LN68
	DD	imagerel $LN68+35
	DD	imagerel $unwind$?hooked_fptr@core_hook@@YA_JPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hooked_fptr@core_hook@@YA_JPEAX@Z DD 020602H
	DD	03002d206H
xdata	ENDS
; Function compile flags: /Ogtp
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\km\wdm.h
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\km\wdm.h
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp
;	COMDAT ?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z
_TEXT	SEGMENT
compareString$ = 32
ansiString$ = 48
processId$ = 96
moduleName$ = 104
baseAddress$ = 112
process$ = 120
?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z PROC		; GetModuleBaseAddress, COMDAT

; 25   : {

$LN35:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 56		 push	 r14
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00009	48 63 d9	 movsxd	 rbx, ecx
  0000c	4d 8b f0	 mov	 r14, r8

; 26   : 	ANSI_STRING ansiString;
; 27   : 	UNICODE_STRING compareString;
; 28   : 	KAPC_STATE state;
; 29   : 	NTSTATUS status = STATUS_UNSUCCESSFUL;
; 30   : 	PEPROCESS process = NULL;
; 31   : 	system::PPEB pPeb = NULL;
; 32   : 
; 33   : 	RtlInitAnsiString(&ansiString, moduleName);

  0000f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ansiString$[rsp]
  00014	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR process$[rsp], 0
  0001d	48 c7 c6 01 00
	00 c0		 mov	 rsi, -1073741823	; ffffffffc0000001H
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 34   : 	RtlAnsiStringToUnicodeString(&compareString, &ansiString, TRUE);

  0002a	41 b0 01	 mov	 r8b, 1
  0002d	48 8d 54 24 30	 lea	 rdx, QWORD PTR ansiString$[rsp]
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR compareString$[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAnsiStringToUnicodeString

; 35   : 
; 36   : 	printf("Looking for module %d\n", processId);
; 37   : 
; 38   : 	if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)processId, &process)))

  0003d	48 8b cb	 mov	 rcx, rbx
  00040	48 8d 54 24 78	 lea	 rdx, QWORD PTR process$[rsp]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId
  0004b	85 c0		 test	 eax, eax
  0004d	0f 88 cb 00 00
	00		 js	 $LN33@GetModuleB
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\km\wdm.h

; 123  :     return (struct _KTHREAD *)__readgsqword(0x188);

  00053	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp

; 43   : 	auto o_process = swap_process((uintptr_t)process);

  0005c	48 8b 54 24 78	 mov	 rdx, QWORD PTR process$[rsp]
  00061	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp

; 10   : 	if (!usermodeThread)

  00066	48 85 c9	 test	 rcx, rcx
  00069	75 05		 jne	 SHORT $LN16@GetModuleB

; 11   : 		return STATUS_UNSUCCESSFUL;

  0006b	48 8b ee	 mov	 rbp, rsi
  0006e	eb 1b		 jmp	 SHORT $LN15@GetModuleB
$LN16@GetModuleB:

; 12   : 
; 13   : 	auto apc_state = *(uintptr_t*)(usermodeThread + 0x98);

  00070	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]

; 14   : 	auto old_process = *(uintptr_t*)(apc_state + 0x20);
; 15   : 	*(uintptr_t*)(apc_state + 0x20) = new_process;

  00077	48 8b 44 24 78	 mov	 rax, QWORD PTR process$[rsp]
  0007c	48 8b 69 20	 mov	 rbp, QWORD PTR [rcx+32]
  00080	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 16   : 
; 17   : 	auto dir_table_base = *(uintptr_t*)(new_process + 0x28);
; 18   : 	__writecr3(dir_table_base);

  00084	48 8b 42 28	 mov	 rax, QWORD PTR [rdx+40]
  00088	0f 22 d8	 mov	 cr3, rax
$LN15@GetModuleB:

; 44   : 	pPeb = process::PsGetProcessPeb(process);

  0008b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR process$[rsp]
  00090	e8 00 00 00 00	 call	 PsGetProcessPeb

; 45   : 
; 46   : 	if (pPeb)

  00095	48 85 c0	 test	 rax, rax
  00098	74 54		 je	 SHORT $LN3@GetModuleB
  0009a	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi

; 47   : 	{
; 48   : 		system::PPEB_LDR_DATA pLdr = (system::PPEB_LDR_DATA)pPeb->Ldr;

  0009f	48 8b 78 18	 mov	 rdi, QWORD PTR [rax+24]

; 49   : 
; 50   : 		if (pLdr)

  000a3	48 85 ff	 test	 rdi, rdi
  000a6	74 41		 je	 SHORT $LN32@GetModuleB

; 51   : 		{
; 52   : 			for (PLIST_ENTRY listEntry = (PLIST_ENTRY)pLdr->InLoadOrderModuleList.Flink;

  000a8	48 8b 5f 10	 mov	 rbx, QWORD PTR [rdi+16]
  000ac	48 83 c7 10	 add	 rdi, 16

; 53   : 				listEntry != &pLdr->InLoadOrderModuleList;

  000b0	48 3b df	 cmp	 rbx, rdi
  000b3	74 34		 je	 SHORT $LN32@GetModuleB
  000b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@GetModuleB:

; 54   : 				listEntry = (PLIST_ENTRY)listEntry->Flink) {
; 55   : 
; 56   : 				system::PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(listEntry, system::LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
; 57   : 				printf("%wZ\n", pEntry->BaseDllName);
; 58   : 				if (RtlCompareUnicodeString(&pEntry->BaseDllName, &compareString, TRUE) == 0)

  000c0	48 8d 4b 58	 lea	 rcx, QWORD PTR [rbx+88]
  000c4	41 b0 01	 mov	 r8b, 1
  000c7	48 8d 54 24 20	 lea	 rdx, QWORD PTR compareString$[rsp]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCompareUnicodeString
  000d2	85 c0		 test	 eax, eax
  000d4	74 0a		 je	 SHORT $LN21@GetModuleB

; 53   : 				listEntry != &pLdr->InLoadOrderModuleList;

  000d6	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  000d9	48 3b df	 cmp	 rbx, rdi
  000dc	75 e2		 jne	 SHORT $LL4@GetModuleB

; 54   : 				listEntry = (PLIST_ENTRY)listEntry->Flink) {
; 55   : 
; 56   : 				system::PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(listEntry, system::LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
; 57   : 				printf("%wZ\n", pEntry->BaseDllName);
; 58   : 				if (RtlCompareUnicodeString(&pEntry->BaseDllName, &compareString, TRUE) == 0)

  000de	eb 09		 jmp	 SHORT $LN32@GetModuleB
$LN21@GetModuleB:

; 59   : 				{
; 60   : 					*baseAddress = (uint64_t)pEntry->DllBase;

  000e0	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]

; 61   : 					status = STATUS_SUCCESS;

  000e4	33 f6		 xor	 esi, esi
  000e6	49 89 06	 mov	 QWORD PTR [r14], rax
$LN32@GetModuleB:
  000e9	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
$LN3@GetModuleB:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\km\wdm.h

; 123  :     return (struct _KTHREAD *)__readgsqword(0x188);

  000ee	65 48 8b 04 25
	88 01 00 00	 mov	 rax, QWORD PTR gs:392
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp

; 10   : 	if (!usermodeThread)

  000f7	48 85 c0	 test	 rax, rax
  000fa	74 12		 je	 SHORT $LN10@GetModuleB

; 14   : 	auto old_process = *(uintptr_t*)(apc_state + 0x20);
; 15   : 	*(uintptr_t*)(apc_state + 0x20) = new_process;

  000fc	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00103	48 89 68 20	 mov	 QWORD PTR [rax+32], rbp

; 16   : 
; 17   : 	auto dir_table_base = *(uintptr_t*)(new_process + 0x28);
; 18   : 	__writecr3(dir_table_base);

  00107	48 8b 45 28	 mov	 rax, QWORD PTR [rbp+40]
  0010b	0f 22 d8	 mov	 cr3, rax
$LN10@GetModuleB:

; 62   : 					break;
; 63   : 				}
; 64   : 			}
; 65   : 		}
; 66   : 	}
; 67   : 	swap_process(o_process);
; 68   : 	RtlFreeUnicodeString(&compareString);

  0010e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR compareString$[rsp]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlFreeUnicodeString

; 69   : 	return status;

  00119	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
$LN33@GetModuleB:

; 70   : }

  0011e	8b c6		 mov	 eax, esi
  00120	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00124	41 5e		 pop	 r14
  00126	5e		 pop	 rsi
  00127	5b		 pop	 rbx
  00128	c3		 ret	 0
?GetModuleBaseAddress@@YAJHPEBDPEA_K@Z ENDP		; GetModuleBaseAddress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\km\wdm.h
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp
;	COMDAT ?swap_process@@YA_K_K@Z
_TEXT	SEGMENT
new_process$ = 8
?swap_process@@YA_K_K@Z PROC				; swap_process, COMDAT

; 8    : {

  00000	48 8b d1	 mov	 rdx, rcx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\km\wdm.h

; 123  :     return (struct _KTHREAD *)__readgsqword(0x188);

  00003	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp

; 10   : 	if (!usermodeThread)

  0000c	48 85 c9	 test	 rcx, rcx
  0000f	75 08		 jne	 SHORT $LN2@swap_proce

; 11   : 		return STATUS_UNSUCCESSFUL;

  00011	48 c7 c0 01 00
	00 c0		 mov	 rax, -1073741823	; ffffffffc0000001H

; 19   : 
; 20   : 	return old_process;
; 21   : }

  00018	c3		 ret	 0
$LN2@swap_proce:

; 12   : 
; 13   : 	auto apc_state = *(uintptr_t*)(usermodeThread + 0x98);

  00019	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]

; 14   : 	auto old_process = *(uintptr_t*)(apc_state + 0x20);

  00020	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]

; 15   : 	*(uintptr_t*)(apc_state + 0x20) = new_process;

  00024	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx

; 16   : 
; 17   : 	auto dir_table_base = *(uintptr_t*)(new_process + 0x28);
; 18   : 	__writecr3(dir_table_base);

  00028	48 8b 4a 28	 mov	 rcx, QWORD PTR [rdx+40]
  0002c	0f 22 d9	 mov	 cr3, rcx

; 19   : 
; 20   : 	return old_process;
; 21   : }

  0002f	c3		 ret	 0
?swap_process@@YA_K_K@Z ENDP				; swap_process
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\km\wdm.h
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\km\wdm.h
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp
;	COMDAT ?hooked_fptr@core_hook@@YA_JPEAX@Z
_TEXT	SEGMENT
compareString$1 = 48
ansiString$2 = 64
process$3 = 128
status$4 = 128
a1$ = 128
?hooked_fptr@core_hook@@YA_JPEAX@Z PROC			; core_hook::hooked_fptr, COMDAT

; 73   : {

$LN68:
  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8b d9	 mov	 rbx, rcx

; 74   : 	if (!a1 || ExGetPreviousMode() != UserMode)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	0f 84 a1 02 00
	00		 je	 $LN5@hooked_fpt
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExGetPreviousMode
  00018	3c 01		 cmp	 al, 1
  0001a	0f 85 93 02 00
	00		 jne	 $LN5@hooked_fpt

; 78   : 	}
; 79   : 
; 80   : 	fptr_data::kernel_com *com = (fptr_data::kernel_com *)a1;
; 81   : 	com->error = fptr_data::kernel_err::no_error;
; 82   : 	
; 83   : 	switch (com->opr)

  00020	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  00023	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00028	45 33 e4	 xor	 r12d, r12d
  0002b	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00030	66 44 89 63 02	 mov	 WORD PTR [rbx+2], r12w
  00035	83 e9 01	 sub	 ecx, 1
  00038	0f 84 39 02 00
	00		 je	 $LN13@hooked_fpt
  0003e	83 e9 01	 sub	 ecx, 1
  00041	0f 84 03 02 00
	00		 je	 $LN11@hooked_fpt
  00047	83 e9 01	 sub	 ecx, 1
  0004a	74 7c		 je	 SHORT $LN8@hooked_fpt
  0004c	83 f9 01	 cmp	 ecx, 1
  0004f	74 1e		 je	 SHORT $LN6@hooked_fpt

; 143  : 			}
; 144  : 			break;
; 145  : 		}
; 146  : 
; 147  : 		default:
; 148  : 		{
; 149  : 			com->success = false;

  00051	44 88 23	 mov	 BYTE PTR [rbx], r12b

; 150  : 			com->error = fptr_data::kernel_err::no_operation;

  00054	b8 04 00 00 00	 mov	 eax, 4
$LN65@hooked_fpt:

; 138  : 			{
; 139  : 				com->success = false;
; 140  : 				com->error = fptr_data::kernel_err::invalid_data;
; 141  : 				printf("read failed: invalid data.\n");
; 142  : 				return 0;

  00059	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0005e	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  00063	66 89 43 02	 mov	 WORD PTR [rbx+2], ax
  00067	33 c0		 xor	 eax, eax

; 157  : 	printf("kernel operation completed successfully.\n");
; 158  : 	return 0;
; 159  : }

  00069	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0006d	5b		 pop	 rbx
  0006e	c3		 ret	 0
$LN6@hooked_fpt:

; 84   : 	{
; 85   : 		case fptr_data::kernel_opr::get_process_base:
; 86   : 		{
; 87   : 			NTSTATUS status = STATUS_SUCCESS;
; 88   : 
; 89   : 			PEPROCESS proc = process::get_by_id(com->target_pid, &status);

  0006f	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  00072	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR status$4[rsp]
  0007a	44 89 a4 24 80
	00 00 00	 mov	 DWORD PTR status$4[rsp], r12d
  00082	e8 00 00 00 00	 call	 ?get_by_id@process@@YAPEAU_KPROCESS@@IPEAJ@Z ; process::get_by_id
  00087	48 8b f8	 mov	 rdi, rax

; 90   : 			if (!NT_SUCCESS(status))

  0008a	44 39 a4 24 80
	00 00 00	 cmp	 DWORD PTR status$4[rsp], r12d
  00092	7d 0a		 jge	 SHORT $LN7@hooked_fpt

; 91   : 			{
; 92   : 				com->error = fptr_data::kernel_err::invalid_process;

  00094	b8 02 00 00 00	 mov	 eax, 2

; 93   : 				com->success = false;

  00099	44 88 23	 mov	 BYTE PTR [rbx], r12b

; 94   : 
; 95   : 				printf("get_process_base failed: invalid process.\n");
; 96   : 				return 0;

  0009c	eb bb		 jmp	 SHORT $LN65@hooked_fpt
$LN7@hooked_fpt:

; 97   : 			}
; 98   : 
; 99   : 			com->buffer = (uintptr_t)process::PsGetProcessSectionBaseAddress(proc);

  0009e	48 8b cf	 mov	 rcx, rdi
  000a1	e8 00 00 00 00	 call	 PsGetProcessSectionBaseAddress

; 100  : 			ObDereferenceObject(proc);

  000a6	48 8b cf	 mov	 rcx, rdi
  000a9	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
  000b3	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]

; 138  : 			{
; 139  : 				com->success = false;
; 140  : 				com->error = fptr_data::kernel_err::invalid_data;
; 141  : 				printf("read failed: invalid data.\n");
; 142  : 				return 0;

  000b8	33 c0		 xor	 eax, eax
  000ba	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]

; 151  : 			printf("(%p) failed: unknown operation.\n", com->opr);
; 152  : 			return 0;
; 153  : 		}
; 154  : 	}
; 155  : 
; 156  : 	com->success = true;

  000bf	c6 03 01	 mov	 BYTE PTR [rbx], 1

; 157  : 	printf("kernel operation completed successfully.\n");
; 158  : 	return 0;
; 159  : }

  000c2	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000c6	5b		 pop	 rbx
  000c7	c3		 ret	 0
$LN8@hooked_fpt:

; 101  : 			break;
; 102  : 		}
; 103  : 		case fptr_data::kernel_opr::get_process_module:
; 104  : 		{
; 105  : 			// Inputs
; 106  : 			if (!com->target_pid)

  000c8	48 63 7b 18	 movsxd	 rdi, DWORD PTR [rbx+24]
  000cc	85 ff		 test	 edi, edi
  000ce	75 1e		 jne	 SHORT $LN9@hooked_fpt

; 107  : 			{
; 108  : 				com->error = fptr_data::kernel_err::invalid_data;

  000d0	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  000d5	b8 05 00 00 00	 mov	 eax, 5
  000da	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  000df	66 89 43 02	 mov	 WORD PTR [rbx+2], ax

; 138  : 			{
; 139  : 				com->success = false;
; 140  : 				com->error = fptr_data::kernel_err::invalid_data;
; 141  : 				printf("read failed: invalid data.\n");
; 142  : 				return 0;

  000e3	33 c0		 xor	 eax, eax

; 151  : 			printf("(%p) failed: unknown operation.\n", com->opr);
; 152  : 			return 0;
; 153  : 		}
; 154  : 	}
; 155  : 
; 156  : 	com->success = true;

  000e5	c6 03 01	 mov	 BYTE PTR [rbx], 1

; 157  : 	printf("kernel operation completed successfully.\n");
; 158  : 	return 0;
; 159  : }

  000e8	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000ec	5b		 pop	 rbx
  000ed	c3		 ret	 0
$LN9@hooked_fpt:

; 33   : 	RtlInitAnsiString(&ansiString, moduleName);

  000ee	48 8b 93 48 01
	00 00		 mov	 rdx, QWORD PTR [rbx+328]
  000f5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ansiString$2[rsp]
  000fa	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14

; 19   : 
; 20   : 	return old_process;
; 21   : }
; 22   : 
; 23   : 
; 24   : NTSTATUS GetModuleBaseAddress(int processId, const char* moduleName, uint64_t* baseAddress)
; 25   : {
; 26   : 	ANSI_STRING ansiString;
; 27   : 	UNICODE_STRING compareString;
; 28   : 	KAPC_STATE state;
; 29   : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

  000ff	49 c7 c6 01 00
	00 c0		 mov	 r14, -1073741823	; ffffffffc0000001H
  00106	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15

; 109  : 				com->success = false;
; 110  : 				printf("get_process_module failed: no valid process id given.\n");
; 111  : 				break;
; 112  : 			}
; 113  : 
; 114  : 
; 115  : 			uintptr_t buffer = 0;

  0010b	4d 8b fc	 mov	 r15, r12

; 116  : 			com->buffer = 0;

  0010e	4c 89 63 28	 mov	 QWORD PTR [rbx+40], r12

; 30   : 	PEPROCESS process = NULL;

  00112	4c 89 a4 24 80
	00 00 00	 mov	 QWORD PTR process$3[rsp], r12

; 31   : 	system::PPEB pPeb = NULL;
; 32   : 
; 33   : 	RtlInitAnsiString(&ansiString, moduleName);

  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 34   : 	RtlAnsiStringToUnicodeString(&compareString, &ansiString, TRUE);

  00120	41 b0 01	 mov	 r8b, 1
  00123	48 8d 54 24 40	 lea	 rdx, QWORD PTR ansiString$2[rsp]
  00128	48 8d 4c 24 30	 lea	 rcx, QWORD PTR compareString$1[rsp]
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAnsiStringToUnicodeString

; 35   : 
; 36   : 	printf("Looking for module %d\n", processId);
; 37   : 
; 38   : 	if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)processId, &process)))

  00133	48 8b cf	 mov	 rcx, rdi
  00136	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR process$3[rsp]
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId
  00144	85 c0		 test	 eax, eax
  00146	0f 88 df 00 00
	00		 js	 $LN62@hooked_fpt
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\km\wdm.h

; 123  :     return (struct _KTHREAD *)__readgsqword(0x188);

  0014c	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp

; 43   : 	auto o_process = swap_process((uintptr_t)process);

  00155	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR process$3[rsp]
  0015d	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbp

; 10   : 	if (!usermodeThread)

  00165	48 85 c9	 test	 rcx, rcx
  00168	75 05		 jne	 SHORT $LN32@hooked_fpt

; 11   : 		return STATUS_UNSUCCESSFUL;

  0016a	49 8b ee	 mov	 rbp, r14
  0016d	eb 1e		 jmp	 SHORT $LN31@hooked_fpt
$LN32@hooked_fpt:

; 12   : 
; 13   : 	auto apc_state = *(uintptr_t*)(usermodeThread + 0x98);

  0016f	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]

; 14   : 	auto old_process = *(uintptr_t*)(apc_state + 0x20);
; 15   : 	*(uintptr_t*)(apc_state + 0x20) = new_process;

  00176	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR process$3[rsp]
  0017e	48 8b 69 20	 mov	 rbp, QWORD PTR [rcx+32]
  00182	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 16   : 
; 17   : 	auto dir_table_base = *(uintptr_t*)(new_process + 0x28);
; 18   : 	__writecr3(dir_table_base);

  00186	48 8b 42 28	 mov	 rax, QWORD PTR [rdx+40]
  0018a	0f 22 d8	 mov	 cr3, rax
$LN31@hooked_fpt:

; 44   : 	pPeb = process::PsGetProcessPeb(process);

  0018d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR process$3[rsp]
  00195	e8 00 00 00 00	 call	 PsGetProcessPeb

; 45   : 
; 46   : 	if (pPeb)

  0019a	48 85 c0	 test	 rax, rax
  0019d	74 50		 je	 SHORT $LN19@hooked_fpt
  0019f	48 89 b4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rsi

; 47   : 	{
; 48   : 		system::PPEB_LDR_DATA pLdr = (system::PPEB_LDR_DATA)pPeb->Ldr;

  001a7	48 8b 70 18	 mov	 rsi, QWORD PTR [rax+24]

; 49   : 
; 50   : 		if (pLdr)

  001ab	48 85 f6	 test	 rsi, rsi
  001ae	74 37		 je	 SHORT $LN63@hooked_fpt

; 51   : 		{
; 52   : 			for (PLIST_ENTRY listEntry = (PLIST_ENTRY)pLdr->InLoadOrderModuleList.Flink;

  001b0	48 8b 7e 10	 mov	 rdi, QWORD PTR [rsi+16]
  001b4	48 83 c6 10	 add	 rsi, 16

; 53   : 				listEntry != &pLdr->InLoadOrderModuleList;

  001b8	48 3b fe	 cmp	 rdi, rsi
  001bb	74 2a		 je	 SHORT $LN63@hooked_fpt
  001bd	0f 1f 00	 npad	 3
$LL20@hooked_fpt:

; 54   : 				listEntry = (PLIST_ENTRY)listEntry->Flink) {
; 55   : 
; 56   : 				system::PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(listEntry, system::LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
; 57   : 				printf("%wZ\n", pEntry->BaseDllName);
; 58   : 				if (RtlCompareUnicodeString(&pEntry->BaseDllName, &compareString, TRUE) == 0)

  001c0	48 8d 4f 58	 lea	 rcx, QWORD PTR [rdi+88]
  001c4	41 b0 01	 mov	 r8b, 1
  001c7	48 8d 54 24 30	 lea	 rdx, QWORD PTR compareString$1[rsp]
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCompareUnicodeString
  001d2	85 c0		 test	 eax, eax
  001d4	74 0a		 je	 SHORT $LN37@hooked_fpt

; 53   : 				listEntry != &pLdr->InLoadOrderModuleList;

  001d6	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
  001d9	48 3b fe	 cmp	 rdi, rsi
  001dc	75 e2		 jne	 SHORT $LL20@hooked_fpt

; 54   : 				listEntry = (PLIST_ENTRY)listEntry->Flink) {
; 55   : 
; 56   : 				system::PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(listEntry, system::LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
; 57   : 				printf("%wZ\n", pEntry->BaseDllName);
; 58   : 				if (RtlCompareUnicodeString(&pEntry->BaseDllName, &compareString, TRUE) == 0)

  001de	eb 07		 jmp	 SHORT $LN63@hooked_fpt
$LN37@hooked_fpt:

; 59   : 				{
; 60   : 					*baseAddress = (uint64_t)pEntry->DllBase;

  001e0	4c 8b 7f 30	 mov	 r15, QWORD PTR [rdi+48]

; 61   : 					status = STATUS_SUCCESS;

  001e4	45 8b f4	 mov	 r14d, r12d
$LN63@hooked_fpt:
  001e7	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR [rsp+144]
$LN19@hooked_fpt:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\km\wdm.h

; 123  :     return (struct _KTHREAD *)__readgsqword(0x188);

  001ef	65 48 8b 04 25
	88 01 00 00	 mov	 rax, QWORD PTR gs:392
; File C:\Users\leonk\OneDrive\Desktop\EAC\driver\core\hook.cpp

; 10   : 	if (!usermodeThread)

  001f8	48 85 c0	 test	 rax, rax
  001fb	74 12		 je	 SHORT $LN26@hooked_fpt

; 14   : 	auto old_process = *(uintptr_t*)(apc_state + 0x20);
; 15   : 	*(uintptr_t*)(apc_state + 0x20) = new_process;

  001fd	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00204	48 89 68 20	 mov	 QWORD PTR [rax+32], rbp

; 16   : 
; 17   : 	auto dir_table_base = *(uintptr_t*)(new_process + 0x28);
; 18   : 	__writecr3(dir_table_base);

  00208	48 8b 45 28	 mov	 rax, QWORD PTR [rbp+40]
  0020c	0f 22 d8	 mov	 cr3, rax
$LN26@hooked_fpt:

; 68   : 	RtlFreeUnicodeString(&compareString);

  0020f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR compareString$1[rsp]
  00214	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlFreeUnicodeString
  0021a	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR [rsp+136]

; 117  : 			if ( NT_SUCCESS( GetModuleBaseAddress( com->target_pid, com->name, &buffer ) ) )

  00222	45 85 f6	 test	 r14d, r14d
  00225	78 04		 js	 SHORT $LN62@hooked_fpt

; 118  : 				com->buffer = buffer;

  00227	4c 89 7b 28	 mov	 QWORD PTR [rbx+40], r15
$LN62@hooked_fpt:
  0022b	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00230	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]
$LN14@hooked_fpt:
  00235	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]

; 138  : 			{
; 139  : 				com->success = false;
; 140  : 				com->error = fptr_data::kernel_err::invalid_data;
; 141  : 				printf("read failed: invalid data.\n");
; 142  : 				return 0;

  0023a	33 c0		 xor	 eax, eax
  0023c	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]

; 151  : 			printf("(%p) failed: unknown operation.\n", com->opr);
; 152  : 			return 0;
; 153  : 		}
; 154  : 	}
; 155  : 
; 156  : 	com->success = true;

  00241	c6 03 01	 mov	 BYTE PTR [rbx], 1

; 157  : 	printf("kernel operation completed successfully.\n");
; 158  : 	return 0;
; 159  : }

  00244	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00248	5b		 pop	 rbx
  00249	c3		 ret	 0
$LN11@hooked_fpt:

; 119  : 			break;
; 120  : 			
; 121  : 			break;
; 122  : 		}
; 123  : 
; 124  : 		case fptr_data::kernel_opr::write:
; 125  : 		{
; 126  : 			if (!NT_SUCCESS(memory::write_process_memory(com->target_pid, com->user_pid, com->address, com->buffer, com->size, &com->transfer)))

  0024a	4c 8b 4b 28	 mov	 r9, QWORD PTR [rbx+40]
  0024e	48 8d 83 50 01
	00 00		 lea	 rax, QWORD PTR [rbx+336]
  00255	4c 8b 43 20	 mov	 r8, QWORD PTR [rbx+32]
  00259	8b 53 1c	 mov	 edx, DWORD PTR [rbx+28]
  0025c	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  0025f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00264	48 8b 83 48 01
	00 00		 mov	 rax, QWORD PTR [rbx+328]
  0026b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00270	e8 00 00 00 00	 call	 ?write_process_memory@memory@@YAJII_K00PEA_K@Z ; memory::write_process_memory

; 127  : 			{
; 128  : 				com->success = false;
; 129  : 				com->error = fptr_data::kernel_err::invalid_data;
; 130  : 				printf("write failed: invalid data.\n");
; 131  : 				return 0;

  00275	eb 2b		 jmp	 SHORT $LN66@hooked_fpt
$LN13@hooked_fpt:

; 132  : 			}
; 133  : 			break;
; 134  : 		}
; 135  : 		case fptr_data::kernel_opr::read:
; 136  : 		{
; 137  : 			if (!NT_SUCCESS(memory::read_process_memory(com->target_pid, com->user_pid, com->address, com->buffer, com->size, &com->transfer)))

  00277	4c 8b 4b 28	 mov	 r9, QWORD PTR [rbx+40]
  0027b	48 8d 83 50 01
	00 00		 lea	 rax, QWORD PTR [rbx+336]
  00282	4c 8b 43 20	 mov	 r8, QWORD PTR [rbx+32]
  00286	8b 53 1c	 mov	 edx, DWORD PTR [rbx+28]
  00289	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  0028c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00291	48 8b 83 48 01
	00 00		 mov	 rax, QWORD PTR [rbx+328]
  00298	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029d	e8 00 00 00 00	 call	 ?read_process_memory@memory@@YAJII_K00PEA_K@Z ; memory::read_process_memory
$LN66@hooked_fpt:

; 138  : 			{
; 139  : 				com->success = false;
; 140  : 				com->error = fptr_data::kernel_err::invalid_data;
; 141  : 				printf("read failed: invalid data.\n");
; 142  : 				return 0;

  002a2	85 c0		 test	 eax, eax
  002a4	79 8f		 jns	 SHORT $LN14@hooked_fpt
  002a6	44 88 23	 mov	 BYTE PTR [rbx], r12b
  002a9	b8 05 00 00 00	 mov	 eax, 5
  002ae	e9 a6 fd ff ff	 jmp	 $LN65@hooked_fpt
$LN5@hooked_fpt:

; 75   : 	{
; 76   : 		printf("!a1 || ExGetPreviousMode() != UserMode fail. arguments: %16X\n", a1);
; 77   : 		return core_hook::o_function_qword_1(a1);

  002b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?o_function_qword_1@core_hook@@3P6A_JPEAX@ZEA ; core_hook::o_function_qword_1
  002ba	48 8b cb	 mov	 rcx, rbx

; 157  : 	printf("kernel operation completed successfully.\n");
; 158  : 	return 0;
; 159  : }

  002bd	48 83 c4 70	 add	 rsp, 112		; 00000070H
  002c1	5b		 pop	 rbx

; 75   : 	{
; 76   : 		printf("!a1 || ExGetPreviousMode() != UserMode fail. arguments: %16X\n", a1);
; 77   : 		return core_hook::o_function_qword_1(a1);

  002c2	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __guard_dispatch_icall_fptr
?hooked_fptr@core_hook@@YA_JPEAX@Z ENDP			; core_hook::hooked_fptr
_TEXT	ENDS
END
